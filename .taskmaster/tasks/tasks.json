{
  "master": {
    "tasks": [
      {
        "id": 1,
        "title": "Setup Project Structure and Dependencies",
        "description": "Initialize the project structure and create the pyproject.toml file with necessary dependencies for the eval-crypt package.",
        "status": "done",
        "dependencies": [],
        "priority": "high",
        "details": "Create a standard Python package structure with the following components:\n1. Create directory structure:\n   - eval_crypt/ (main package)\n   - tests/\n   - docs/\n2. Create pyproject.toml with the following dependencies:\n   - pycryptodome (for AES encryption)\n   - click (for CLI implementation)\n   - pre-commit (for git hooks)\n3. Setup basic package metadata:\n```toml\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"eval-crypt\"\nversion = \"0.1.0\"\ndescription = \"A tool to encrypt sensitive AI safety evaluation files in Git repositories\"\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\nlicense = {text = \"MIT\"}\ndependencies = [\n    \"click>=8.0.0\",\n    \"pycryptodome>=3.15.0\",\n    \"pre-commit>=2.20.0\",\n]\n\n[project.scripts]\neval-crypt = \"eval_crypt.cli:main\"\n```\n4. Create a basic README.md with installation and usage instructions\n5. Note that the CLI will only manage the list of files to be encrypted/decrypted, while the actual encryption/decryption operations will be handled automatically by git hooks",
        "testStrategy": "Verify the package structure is correct and that the package can be installed with pip install -e . in development mode. Ensure all dependencies are correctly specified and the package metadata is accurate. Test that the CLI correctly manages the list of files to be encrypted/decrypted and that the git hooks are properly configured.",
        "subtasks": [
          {
            "id": 2,
            "title": "Create pyproject.toml with Dependencies",
            "description": "Create the pyproject.toml file with necessary dependencies for the package.",
            "status": "done",
            "dependencies": [
              1
            ],
            "details": "Create pyproject.toml in the root directory with the following content:\n[build-system]\nrequires = [\"setuptools>=42\", \"wheel\"]\nbuild-backend = \"setuptools.build_meta\"\n\n[project]\nname = \"eval-crypt\"\nversion = \"0.1.0\"\ndescription = \"A tool to encrypt sensitive AI safety evaluation files in Git repositories\"\nreadme = \"README.md\"\nrequires-python = \">=3.8\"\nlicense = {text = \"MIT\"}\ndependencies = [\n    \"click>=8.0.0\",\n    \"pycryptodome>=3.15.0\",\n    \"pre-commit>=2.20.0\",\n]\n\n[project.scripts]\neval-crypt = \"eval_crypt.cli:main\"",
            "testStrategy": ""
          },
          {
            "id": 3,
            "title": "Create Basic README.md",
            "description": "Create a comprehensive README.md file with installation and usage instructions for the package.",
            "status": "done",
            "dependencies": [
              2
            ],
            "details": "Create README.md in the root directory with the following sections:\n1. Project title and brief description\n2. Installation instructions (pip install, development setup)\n3. Basic usage examples\n4. Features overview\n5. License information\n\nExample content:\n# eval-crypt\n\nA tool to encrypt sensitive AI safety evaluation files in Git repositories.\n\n## Installation\n\n```bash\npip install eval-crypt\n```\n\nFor development:\n```bash\ngit clone https://github.com/username/eval-crypt.git\ncd eval-crypt\npip install -e .\n```\n\n## Usage\n\n```bash\n# Add a file to be automatically encrypted/decrypted by git hooks\neval-crypt add path/to/sensitive/file.txt\n\n# Remove a file from automatic encryption/decryption\neval-crypt remove path/to/sensitive/file.txt\n\n# List all files being managed for encryption/decryption\neval-crypt list\n```\n\n## Features\n\n- Secure AES encryption for sensitive files\n- Simple CLI interface for managing encrypted files\n- Automatic encryption/decryption via git hooks\n- Seamless integration with your Git workflow\n\n## License\n\nMIT",
            "testStrategy": ""
          },
          {
            "id": 4,
            "title": "Create Basic CLI Module Structure",
            "description": "Create the initial CLI module structure in the eval_crypt package to enable file management for automatic encryption/decryption via git hooks.",
            "status": "done",
            "dependencies": [
              1,
              2
            ],
            "details": "Create the cli.py file in the eval_crypt directory with a revised CLI structure using Click:\n```python\nimport click\n\n@click.group()\ndef main():\n    \"\"\"eval-crypt: A tool to manage sensitive AI safety evaluation files.\"\"\"\n    pass\n\n@main.command()\n@click.argument('file_path', type=click.Path(exists=True))\ndef add(file_path):\n    \"\"\"Add a file to the managed list for automatic encryption.\"\"\"\n    click.echo(f\"Adding {file_path} to managed files\")\n    # Logic to add file to managed list will be implemented later\n\n@main.command()\n@click.argument('file_path', type=click.Path(exists=True))\ndef remove(file_path):\n    \"\"\"Remove a file from the managed list to stop automatic encryption.\"\"\"\n    click.echo(f\"Removing {file_path} from managed files\")\n    # Logic to remove file from managed list will be implemented later\n\n@main.command()\ndef list():\n    \"\"\"List all files currently being managed for encryption.\"\"\"\n    click.echo(\"Listing all managed files:\")\n    # Logic to display managed files will be implemented later\n\nif __name__ == '__main__':\n    main()\n```\n\nNote: This CLI design aligns with the git hooks approach where files are automatically encrypted/decrypted by git hooks rather than through direct user commands.",
            "testStrategy": ""
          },
          {
            "id": 5,
            "title": "Document Git Hooks Workflow",
            "description": "Document the workflow for how git hooks will automatically handle encryption/decryption of managed files.",
            "status": "done",
            "dependencies": [
              3
            ],
            "details": "Create a document or section in the README.md that explains:\n\n1. How the pre-commit hook will automatically encrypt sensitive files before they are committed\n2. How the post-checkout hook will automatically decrypt files after checkout\n3. How the post-merge hook will handle decryption after merging\n4. The overall workflow from a user perspective\n\nExample content for README.md section:\n\n## How It Works\n\neval-crypt uses git hooks to automatically encrypt and decrypt sensitive files:\n\n1. **Adding files to management**: When you run `eval-crypt add <file>`, the file path is added to a configuration file\n2. **Pre-commit hook**: Before committing, all managed files are automatically encrypted\n3. **Post-checkout hook**: After checkout, all managed files are automatically decrypted\n4. **Post-merge hook**: After merging, all managed files are automatically decrypted\n\nThis means you can work with the unencrypted files locally, but they will always be encrypted in the repository.",
            "testStrategy": ""
          },
          {
            "id": 1,
            "title": "Create Directory Structure",
            "description": "Set up the initial directory structure for the eval-crypt package following standard Python package conventions.",
            "details": "Create the following directory structure:\n- eval_crypt/ (main package)\n  - __init__.py (empty file to mark as package)\n  - cli.py (placeholder for CLI implementation)\n- tests/ (for unit tests)\n  - __init__.py (empty file)\n- docs/ (for documentation)\n  - index.md (placeholder for main documentation)",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 1
          }
        ]
      },
      {
        "id": 2,
        "title": "Implement Core Encryption/Decryption Module",
        "description": "Create the core encryption and decryption functionality using AES encryption from pycryptodome.",
        "details": "Create a module `eval_crypt/crypto.py` that implements the encryption and decryption functionality:\n\n```python\nfrom Crypto.Cipher import AES\nfrom Crypto.Random import get_random_bytes\nimport os\nimport json\nfrom base64 import b64decode, b64encode\nfrom pathlib import Path\nfrom typing import Union, List\n\n\ndef create_or_read_secret_key(key_path: Union[str, Path] = \"anti-pretraining.sk\") -> bytes:\n    \"\"\"Create a new secret key if it doesn't exist, or read the existing one.\"\"\"\n    key_path = Path(key_path)\n    if not key_path.exists():\n        key_path.parent.mkdir(parents=True, exist_ok=True)\n        with open(key_path, \"wb\") as f:\n            sk = get_random_bytes(16)\n            f.write(sk)\n        return sk\n    with open(key_path, \"rb\") as f:\n        return f.read()\n\n\ndef encrypt_file(file_path: Union[str, Path], secret_key: bytes) -> None:\n    \"\"\"Encrypt a file using AES encryption in CTR mode.\"\"\"\n    file_path = Path(file_path)\n    if not file_path.exists():\n        raise FileNotFoundError(f\"File {file_path} not found\")\n        \n    with open(file_path, \"rb\") as f:\n        plaintext = f.read()\n\n    cipher = AES.new(secret_key, AES.MODE_CTR)\n    ciphertext = cipher.encrypt(plaintext)\n    nonce = b64encode(cipher.nonce).decode(\"utf-8\")\n    ct = b64encode(ciphertext).decode(\"utf-8\")\n    result = json.dumps({\"nonce\": nonce, \"ciphertext\": ct})\n    \n    with open(str(file_path) + \".enc\", \"w\") as f:\n        f.write(result)\n    \n    # Remove the original file after encryption\n    os.remove(file_path)\n\n\ndef decrypt_file(file_path: Union[str, Path], secret_key: bytes) -> None:\n    \"\"\"Decrypt a file that was encrypted using encrypt_file.\"\"\"\n    file_path = Path(file_path)\n    enc_path = Path(str(file_path) + \".enc\")\n    \n    if not enc_path.exists():\n        raise FileNotFoundError(f\"Encrypted file {enc_path} not found\")\n    \n    with open(enc_path, \"r\") as f:\n        encrypted_data = json.loads(f.read())\n    \n    try:\n        nonce = b64decode(encrypted_data[\"nonce\"])\n        ciphertext = b64decode(encrypted_data[\"ciphertext\"])\n        cipher = AES.new(secret_key, AES.MODE_CTR, nonce=nonce)\n        plaintext = cipher.decrypt(ciphertext)\n    except (ValueError, KeyError) as e:\n        raise ValueError(f\"Decryption failed: {e}\")\n    \n    with open(file_path, \"wb\") as f:\n        f.write(plaintext)\n    \n    # Remove the encrypted file after decryption\n    os.remove(enc_path)\n\n\ndef get_sensitive_files(gitattributes_path: Union[str, Path] = \".gitattributes\") -> List[str]:\n    \"\"\"Get the list of sensitive files from .gitattributes.\"\"\"\n    gitattributes_path = Path(gitattributes_path)\n    if not gitattributes_path.exists():\n        return []\n    \n    sensitive_files = []\n    with open(gitattributes_path, \"r\") as f:\n        for line in f:\n            if \"filter=eval-crypt\" in line:\n                file_pattern = line.split()[0]\n                sensitive_files.append(file_pattern)\n    \n    return sensitive_files\n```",
        "testStrategy": "Create unit tests for each function in the crypto module. Test creating and reading secret keys, encrypting and decrypting files with various content types (text, binary), and handling edge cases like empty files or non-existent files. Verify that the original file is properly removed after encryption and the encrypted file is removed after decryption.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 3,
        "title": "Implement Git Attributes Configuration",
        "description": "Create functionality to manage the .gitattributes file for tracking which files should be encrypted/decrypted.",
        "details": "Create a module `eval_crypt/gitattributes.py` to handle the .gitattributes file configuration:\n\n```python\nfrom pathlib import Path\nfrom typing import Union, List, Set\nimport re\n\n\ndef add_sensitive_file(file_pattern: str, gitattributes_path: Union[str, Path] = \".gitattributes\") -> None:\n    \"\"\"Add a file pattern to .gitattributes as a sensitive file.\"\"\"\n    gitattributes_path = Path(gitattributes_path)\n    \n    # Create .gitattributes if it doesn't exist\n    if not gitattributes_path.exists():\n        gitattributes_path.parent.mkdir(parents=True, exist_ok=True)\n        gitattributes_path.touch()\n    \n    # Read existing content\n    lines = []\n    if gitattributes_path.stat().st_size > 0:\n        with open(gitattributes_path, \"r\") as f:\n            lines = f.readlines()\n    \n    # Check if the file pattern is already in .gitattributes\n    pattern_regex = re.compile(f\"^{re.escape(file_pattern)}\\s+filter=eval-crypt\")\n    for line in lines:\n        if pattern_regex.match(line.strip()):\n            return  # File pattern already exists\n    \n    # Add the new file pattern\n    with open(gitattributes_path, \"a\") as f:\n        if lines and not lines[-1].endswith(\"\\n\"):\n            f.write(\"\\n\")\n        f.write(f\"{file_pattern} filter=eval-crypt\\n\")\n\n\ndef remove_sensitive_file(file_pattern: str, gitattributes_path: Union[str, Path] = \".gitattributes\") -> bool:\n    \"\"\"Remove a file pattern from .gitattributes.\"\"\"\n    gitattributes_path = Path(gitattributes_path)\n    \n    if not gitattributes_path.exists():\n        return False\n    \n    # Read existing content\n    with open(gitattributes_path, \"r\") as f:\n        lines = f.readlines()\n    \n    # Filter out the line with the file pattern\n    pattern_regex = re.compile(f\"^{re.escape(file_pattern)}\\s+filter=eval-crypt\")\n    new_lines = [line for line in lines if not pattern_regex.match(line.strip())]\n    \n    # Write back the filtered content\n    with open(gitattributes_path, \"w\") as f:\n        f.writelines(new_lines)\n    \n    return len(new_lines) != len(lines)\n\n\ndef get_sensitive_files(gitattributes_path: Union[str, Path] = \".gitattributes\") -> List[str]:\n    \"\"\"Get the list of sensitive file patterns from .gitattributes.\"\"\"\n    gitattributes_path = Path(gitattributes_path)\n    \n    if not gitattributes_path.exists():\n        return []\n    \n    sensitive_files = []\n    with open(gitattributes_path, \"r\") as f:\n        for line in f:\n            if \"filter=eval-crypt\" in line:\n                file_pattern = line.split()[0]\n                sensitive_files.append(file_pattern)\n    \n    return sensitive_files\n```",
        "testStrategy": "Create unit tests for adding, removing, and retrieving sensitive file patterns from .gitattributes. Test with various file patterns, including wildcards. Verify that duplicate entries are not added and that the file is created if it doesn't exist. Test removing patterns that don't exist and verify the function returns the correct boolean value.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 4,
        "title": "Implement Git Filter Configuration",
        "description": "Create functionality to set up Git filter configuration for the eval-crypt tool.",
        "details": "Create a module `eval_crypt/git_config.py` to handle Git filter configuration:\n\n```python\nimport subprocess\nfrom pathlib import Path\nfrom typing import Union, Optional\n\n\ndef configure_git_filters(repo_path: Union[str, Path] = \".\") -> bool:\n    \"\"\"Configure Git filters for eval-crypt in the repository.\"\"\"\n    repo_path = Path(repo_path)\n    \n    try:\n        # Set up clean filter (encryption)\n        subprocess.run(\n            [\"git\", \"config\", \"filter.eval-crypt.clean\", \"eval-crypt clean %f\"],\n            cwd=repo_path,\n            check=True,\n        )\n        \n        # Set up smudge filter (decryption)\n        subprocess.run(\n            [\"git\", \"config\", \"filter.eval-crypt.smudge\", \"eval-crypt smudge %f\"],\n            cwd=repo_path,\n            check=True,\n        )\n        \n        # Set up required flag to ensure filters run even when large files are processed\n        subprocess.run(\n            [\"git\", \"config\", \"filter.eval-crypt.required\", \"true\"],\n            cwd=repo_path,\n            check=True,\n        )\n        \n        return True\n    except subprocess.CalledProcessError:\n        return False\n\n\ndef check_git_filters_configured(repo_path: Union[str, Path] = \".\") -> bool:\n    \"\"\"Check if Git filters for eval-crypt are configured in the repository.\"\"\"\n    repo_path = Path(repo_path)\n    \n    try:\n        # Check clean filter\n        clean_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.clean\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        \n        # Check smudge filter\n        smudge_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.smudge\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        \n        # Check required flag\n        required_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.required\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        \n        return (\n            clean_result.returncode == 0 and\n            smudge_result.returncode == 0 and\n            required_result.returncode == 0 and\n            \"eval-crypt clean\" in clean_result.stdout and\n            \"eval-crypt smudge\" in smudge_result.stdout and\n            \"true\" in required_result.stdout\n        )\n    except subprocess.CalledProcessError:\n        return False\n```",
        "testStrategy": "Create unit tests for configuring and checking Git filters. Use a temporary Git repository for testing. Verify that the filters are correctly configured and that the check function correctly identifies when filters are or are not configured. Test error handling when Git commands fail.",
        "priority": "high",
        "dependencies": [
          1
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 5,
        "title": "Implement Git Hook Scripts",
        "description": "Create pre-commit and post-merge hook scripts to automatically encrypt and decrypt sensitive files.",
        "details": "Create a module `eval_crypt/hooks.py` to handle Git hook installation and implementation:\n\n```python\nimport os\nimport stat\nfrom pathlib import Path\nfrom typing import Union, Optional\n\n\n# Pre-commit hook script template\nPRE_COMMIT_HOOK = \"\"\"#!/bin/sh\n# eval-crypt pre-commit hook to encrypt sensitive files\n\n# Run eval-crypt encrypt command\neval-crypt encrypt\n\n# Continue with the commit\nexit 0\n\"\"\"\n\n# Post-merge hook script template\nPOST_MERGE_HOOK = \"\"\"#!/bin/sh\n# eval-crypt post-merge hook to decrypt sensitive files\n\n# Run eval-crypt decrypt command\neval-crypt decrypt\n\n# Continue with the merge\nexit 0\n\"\"\"\n\n\ndef install_hooks(repo_path: Union[str, Path] = \".\") -> bool:\n    \"\"\"Install pre-commit and post-merge hooks in the repository.\"\"\"\n    repo_path = Path(repo_path)\n    hooks_dir = repo_path / \".git\" / \"hooks\"\n    \n    if not hooks_dir.exists():\n        return False\n    \n    # Install pre-commit hook\n    pre_commit_path = hooks_dir / \"pre-commit\"\n    with open(pre_commit_path, \"w\") as f:\n        f.write(PRE_COMMIT_HOOK)\n    \n    # Make pre-commit hook executable\n    os.chmod(pre_commit_path, os.stat(pre_commit_path).st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)\n    \n    # Install post-merge hook\n    post_merge_path = hooks_dir / \"post-merge\"\n    with open(post_merge_path, \"w\") as f:\n        f.write(POST_MERGE_HOOK)\n    \n    # Make post-merge hook executable\n    os.chmod(post_merge_path, os.stat(post_merge_path).st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)\n    \n    return True\n\n\ndef check_hooks_installed(repo_path: Union[str, Path] = \".\") -> bool:\n    \"\"\"Check if eval-crypt hooks are installed in the repository.\"\"\"\n    repo_path = Path(repo_path)\n    hooks_dir = repo_path / \".git\" / \"hooks\"\n    \n    if not hooks_dir.exists():\n        return False\n    \n    # Check pre-commit hook\n    pre_commit_path = hooks_dir / \"pre-commit\"\n    if not pre_commit_path.exists():\n        return False\n    \n    with open(pre_commit_path, \"r\") as f:\n        pre_commit_content = f.read()\n        if \"eval-crypt encrypt\" not in pre_commit_content:\n            return False\n    \n    # Check post-merge hook\n    post_merge_path = hooks_dir / \"post-merge\"\n    if not post_merge_path.exists():\n        return False\n    \n    with open(post_merge_path, \"r\") as f:\n        post_merge_content = f.read()\n        if \"eval-crypt decrypt\" not in post_merge_content:\n            return False\n    \n    return True\n```",
        "testStrategy": "Create unit tests for installing and checking Git hooks. Use a temporary Git repository for testing. Verify that the hooks are correctly installed with the right permissions and content. Test the check function to ensure it correctly identifies when hooks are or are not installed. Test error handling when the .git/hooks directory doesn't exist.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4
        ],
        "status": "done",
        "subtasks": []
      },
      {
        "id": 6,
        "title": "Implement CLI Commands",
        "description": "Create a command-line interface using Click to provide easy access to eval-crypt functionality.",
        "details": "Create a module `eval_crypt/cli.py` to implement the CLI using Click:\n\n```python\nimport click\nimport os\nfrom pathlib import Path\n\nfrom eval_crypt.crypto import create_or_read_secret_key, encrypt_file, decrypt_file\nfrom eval_crypt.gitattributes import add_sensitive_file, remove_sensitive_file, get_sensitive_files\nfrom eval_crypt.git_config import configure_git_filters, check_git_filters_configured\nfrom eval_crypt.hooks import install_hooks, check_hooks_installed\n\n\n@click.group()\ndef cli():\n    \"\"\"eval-crypt: Encrypt sensitive AI safety evaluation files in Git repositories.\"\"\"\n    pass\n\n\n@cli.command()\ndef init():\n    \"\"\"Initialize eval-crypt in the current repository.\"\"\"\n    # Create secret key\n    key_path = Path(\"anti-pretraining.sk\")\n    if key_path.exists():\n        click.echo(f\"Secret key already exists at {key_path}\")\n    else:\n        sk = create_or_read_secret_key(key_path)\n        click.echo(f\"Created new secret key at {key_path}\")\n    \n    # Configure Git filters\n    if check_git_filters_configured():\n        click.echo(\"Git filters already configured\")\n    else:\n        if configure_git_filters():\n            click.echo(\"Configured Git filters for eval-crypt\")\n        else:\n            click.echo(\"Failed to configure Git filters\")\n    \n    # Install Git hooks\n    if check_hooks_installed():\n        click.echo(\"Git hooks already installed\")\n    else:\n        if install_hooks():\n            click.echo(\"Installed Git hooks for eval-crypt\")\n        else:\n            click.echo(\"Failed to install Git hooks\")\n    \n    click.echo(\"eval-crypt initialized successfully\")\n\n\n@cli.command()\n@click.argument(\"file_pattern\")\ndef add(file_pattern):\n    \"\"\"Add a file pattern to the list of sensitive files.\"\"\"\n    add_sensitive_file(file_pattern)\n    click.echo(f\"Added {file_pattern} to sensitive files\")\n\n\n@cli.command()\n@click.argument(\"file_pattern\")\ndef remove(file_pattern):\n    \"\"\"Remove a file pattern from the list of sensitive files.\"\"\"\n    if remove_sensitive_file(file_pattern):\n        click.echo(f\"Removed {file_pattern} from sensitive files\")\n    else:\n        click.echo(f\"File pattern {file_pattern} not found in sensitive files\")\n\n\n@cli.command()\ndef list():\n    \"\"\"List all sensitive file patterns.\"\"\"\n    sensitive_files = get_sensitive_files()\n    if sensitive_files:\n        click.echo(\"Sensitive files:\")\n        for file_pattern in sensitive_files:\n            click.echo(f\"  {file_pattern}\")\n    else:\n        click.echo(\"No sensitive files configured\")\n\n\n@cli.command()\ndef encrypt():\n    \"\"\"Encrypt all sensitive files (used by pre-commit hook).\"\"\"\n    sk = create_or_read_secret_key()\n    sensitive_patterns = get_sensitive_files()\n    \n    # Find files matching the patterns\n    files_to_encrypt = []\n    for pattern in sensitive_patterns:\n        # Handle simple file patterns (not directories or wildcards)\n        if os.path.exists(pattern) and os.path.isfile(pattern):\n            files_to_encrypt.append(pattern)\n        # TODO: Handle more complex patterns with glob\n    \n    if not files_to_encrypt:\n        click.echo(\"No sensitive files found to encrypt\")\n        return\n    \n    for file_path in files_to_encrypt:\n        try:\n            # Skip already encrypted files\n            if file_path.endswith(\".enc\"):\n                continue\n                \n            # Skip if the encrypted version exists (file already encrypted)\n            if os.path.exists(f\"{file_path}.enc\"):\n                continue\n                \n            encrypt_file(file_path, sk)\n            click.echo(f\"Encrypted {file_path}\")\n        except Exception as e:\n            click.echo(f\"Failed to encrypt {file_path}: {e}\")\n\n\n@cli.command()\ndef decrypt():\n    \"\"\"Decrypt all sensitive files (used by post-merge hook).\"\"\"\n    sk = create_or_read_secret_key()\n    sensitive_patterns = get_sensitive_files()\n    \n    # Find encrypted files\n    files_to_decrypt = []\n    for pattern in sensitive_patterns:\n        enc_pattern = f\"{pattern}.enc\"\n        if os.path.exists(enc_pattern) and os.path.isfile(enc_pattern):\n            files_to_decrypt.append(pattern)\n        # TODO: Handle more complex patterns with glob\n    \n    if not files_to_decrypt:\n        click.echo(\"No encrypted files found to decrypt\")\n        return\n    \n    for file_path in files_to_decrypt:\n        try:\n            decrypt_file(file_path, sk)\n            click.echo(f\"Decrypted {file_path}\")\n        except Exception as e:\n            click.echo(f\"Failed to decrypt {file_path}: {e}\")\n\n\n@cli.command()\n@click.argument(\"file_path\")\ndef clean(file_path):\n    \"\"\"Git clean filter to encrypt a file (used by Git).\"\"\"\n    # This is called by Git during staging\n    sk = create_or_read_secret_key()\n    try:\n        with open(file_path, \"rb\") as f:\n            content = f.read()\n        \n        # Encrypt the content\n        cipher = AES.new(sk, AES.MODE_CTR)\n        encrypted = cipher.encrypt(content)\n        nonce = b64encode(cipher.nonce).decode(\"utf-8\")\n        ct = b64encode(encrypted).decode(\"utf-8\")\n        result = json.dumps({\"nonce\": nonce, \"ciphertext\": ct})\n        \n        # Output to stdout for Git to capture\n        click.echo(result, nl=False)\n    except Exception as e:\n        # On error, return the original content\n        with open(file_path, \"rb\") as f:\n            click.echo(f.read(), nl=False)\n\n\n@cli.command()\n@click.argument(\"file_path\")\ndef smudge(file_path):\n    \"\"\"Git smudge filter to decrypt a file (used by Git).\"\"\"\n    # This is called by Git during checkout\n    sk = create_or_read_secret_key()\n    try:\n        # Read from stdin (Git provides the content)\n        content = click.get_text_stream(\"stdin\").read()\n        \n        # Try to decrypt\n        try:\n            data = json.loads(content)\n            nonce = b64decode(data[\"nonce\"])\n            ciphertext = b64decode(data[\"ciphertext\"])\n            cipher = AES.new(sk, AES.MODE_CTR, nonce=nonce)\n            decrypted = cipher.decrypt(ciphertext)\n            click.echo(decrypted, nl=False)\n        except (json.JSONDecodeError, KeyError, ValueError):\n            # If not valid JSON or not our format, return as is\n            click.echo(content, nl=False)\n    except Exception as e:\n        # On error, return the input unchanged\n        click.echo(content, nl=False)\n\n\ndef main():\n    cli()\n\n\nif __name__ == \"__main__\":\n    main()\n```",
        "testStrategy": "Create unit tests for each CLI command. Use the Click testing utilities to simulate command invocations. Test the init, add, remove, list, encrypt, and decrypt commands with various inputs. Verify that the commands correctly interact with the underlying modules. Test error handling and edge cases, such as adding a file that's already in the list or removing a file that's not in the list.",
        "priority": "high",
        "dependencies": [
          2,
          3,
          4,
          5
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Complete CLI Implementation with Missing Imports",
            "description": "Finalize the CLI implementation by adding missing imports and completing the clean/smudge functions that are referenced but not fully implemented.",
            "dependencies": [],
            "details": "1. Add the missing imports at the top of the file:\n```python\nimport json\nfrom base64 import b64encode, b64decode\nfrom Crypto.Cipher import AES\n```\n\n2. Ensure the clean and smudge functions are properly implemented with the correct AES encryption/decryption logic.\n\n3. Verify that all CLI commands are properly connected to their corresponding functionality in the other modules.\n\n4. Add proper error handling for all commands, especially for file operations that might fail.\n\n5. Implement the TODO items for handling complex file patterns with glob in the encrypt and decrypt commands.",
            "status": "done",
            "testStrategy": "Manual testing of each command to ensure they work as expected. Test with simple file patterns first, then with more complex patterns including wildcards."
          },
          {
            "id": 2,
            "title": "Implement CLI Unit Tests",
            "description": "Create comprehensive unit tests for the CLI commands to ensure they function correctly and handle edge cases appropriately.",
            "dependencies": [],
            "details": "Create a new file `tests/test_cli.py` with the following structure:\n\n```python\nimport os\nimport tempfile\nimport pytest\nfrom click.testing import CliRunner\nfrom pathlib import Path\n\nfrom eval_crypt.cli import cli, init, add, remove, list, encrypt, decrypt, clean, smudge\n\n@pytest.fixture\ndef runner():\n    return CliRunner()\n\n@pytest.fixture\ndef temp_git_repo():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Set up a mock git repo\n        os.chdir(tmpdir)\n        os.system('git init')\n        yield Path(tmpdir)\n\ndef test_init_command(runner, temp_git_repo):\n    result = runner.invoke(init)\n    assert result.exit_code == 0\n    assert \"eval-crypt initialized successfully\" in result.output\n    assert Path(\"anti-pretraining.sk\").exists()\n\ndef test_add_remove_list_commands(runner, temp_git_repo):\n    # Test add command\n    result = runner.invoke(add, [\"test.txt\"])\n    assert result.exit_code == 0\n    assert \"Added test.txt to sensitive files\" in result.output\n    \n    # Test list command\n    result = runner.invoke(list)\n    assert result.exit_code == 0\n    assert \"test.txt\" in result.output\n    \n    # Test remove command\n    result = runner.invoke(remove, [\"test.txt\"])\n    assert result.exit_code == 0\n    assert \"Removed test.txt from sensitive files\" in result.output\n    \n    # Verify it's gone\n    result = runner.invoke(list)\n    assert result.exit_code == 0\n    assert \"No sensitive files configured\" in result.output\n\ndef test_encrypt_decrypt_commands(runner, temp_git_repo):\n    # Create a test file\n    test_content = \"This is sensitive data\"\n    with open(\"test.txt\", \"w\") as f:\n        f.write(test_content)\n    \n    # Add it as sensitive\n    runner.invoke(add, [\"test.txt\"])\n    \n    # Test encrypt\n    result = runner.invoke(encrypt)\n    assert result.exit_code == 0\n    assert \"Encrypted test.txt\" in result.output\n    assert Path(\"test.txt.enc\").exists()\n    \n    # Test decrypt\n    os.remove(\"test.txt\")  # Remove original to test decryption\n    result = runner.invoke(decrypt)\n    assert result.exit_code == 0\n    assert \"Decrypted test.txt\" in result.output\n    assert Path(\"test.txt\").exists()\n    \n    # Verify content\n    with open(\"test.txt\", \"r\") as f:\n        assert f.read() == test_content\n\ndef test_clean_smudge_commands(runner, temp_git_repo):\n    # Create a test file\n    test_content = \"This is sensitive data\"\n    with open(\"test.txt\", \"w\") as f:\n        f.write(test_content)\n    \n    # Test clean filter\n    result = runner.invoke(clean, [\"test.txt\"])\n    assert result.exit_code == 0\n    # Output should be JSON with nonce and ciphertext\n    assert \"nonce\" in result.output\n    assert \"ciphertext\" in result.output\n    \n    # Test smudge filter by piping clean output to smudge\n    with tempfile.NamedTemporaryFile(mode='w+') as tmp:\n        tmp.write(result.output)\n        tmp.flush()\n        tmp.seek(0)\n        # Simulate stdin with the encrypted content\n        smudge_result = runner.invoke(smudge, [\"test.txt\"], input=result.output)\n        assert smudge_result.exit_code == 0\n        assert smudge_result.output == test_content\n```",
            "status": "done",
            "testStrategy": "Run the tests with pytest. Use mocking where appropriate to isolate the CLI functionality from the underlying implementation. Test both success cases and error handling."
          },
          {
            "id": 3,
            "title": "Implement file management logic for CLI commands",
            "description": "Replace the stub logic in the CLI commands (add, remove, list) with real logic to manage the list of files to be encrypted/decrypted. Store the managed file list in a config file (e.g., .eval-crypt-files or similar) and ensure all commands update and read from this file appropriately.",
            "details": "- Implement persistent storage for the managed file list (e.g., in a .eval-crypt-files config file)\n- Update the add command to append new files to the list\n- Update the remove command to delete files from the list\n- Update the list command to display all managed files\n- Ensure proper error handling and idempotency for all commands\n- Update or add tests to cover the new logic\n<info added on 2025-07-10T12:43:50.680Z>\nImplement persistent storage for managed file list in .gitattributes using 'filter=eval-crypt' attribute, similar to the transcrypt project\n- Update the add command to append new file patterns to .gitattributes with the 'filter=eval-crypt' attribute\n- Update the remove command to delete file patterns from .gitattributes\n- Update the list command to display all managed files by parsing .gitattributes\n- Ensure .gitattributes is the canonical source of truth for which files are managed for encryption/decryption\n- Implement proper error handling for cases where .gitattributes doesn't exist or has invalid format\n- Update or add tests to cover the new .gitattributes-based storage logic\n</info added on 2025-07-10T12:43:50.680Z>",
            "status": "done",
            "dependencies": [],
            "parentTaskId": 6
          }
        ]
      },
      {
        "id": 7,
        "title": "Implement Git Filter Scripts",
        "description": "Create the clean and smudge filter scripts that Git will use to process files during staging and checkout.",
        "status": "pending",
        "dependencies": [
          2,
          6
        ],
        "priority": "high",
        "details": "Enhance the CLI module to properly handle Git filter operations. Update the `eval_crypt/cli.py` file to include implementations of the clean and smudge functions, but note that these should NOT be exposed as user-facing CLI commands. These functions are only to be used by the Git filter/hook integration, not directly by users.\n\n```python\nfrom Crypto.Cipher import AES\nfrom base64 import b64encode, b64decode\nimport json\nimport sys\n\n# ... existing CLI code ...\n\n# Note: These are NOT exposed as CLI commands\n# They are internal functions used by Git filters\ndef clean_filter(file_path):\n    \"\"\"Git clean filter to encrypt a file (used by Git during staging).\"\"\"\n    sk = create_or_read_secret_key()\n    try:\n        # Read the file content\n        with open(file_path, \"rb\") as f:\n            content = f.read()\n        \n        # Check if the content is already encrypted\n        try:\n            json_content = json.loads(content)\n            if \"nonce\" in json_content and \"ciphertext\" in json_content:\n                # Already encrypted, pass through\n                sys.stdout.buffer.write(content)\n                return\n        except (json.JSONDecodeError, UnicodeDecodeError):\n            # Not JSON, continue with encryption\n            pass\n        \n        # Encrypt the content\n        cipher = AES.new(sk, AES.MODE_CTR)\n        encrypted = cipher.encrypt(content)\n        nonce = b64encode(cipher.nonce).decode(\"utf-8\")\n        ct = b64encode(encrypted).decode(\"utf-8\")\n        result = json.dumps({\"nonce\": nonce, \"ciphertext\": ct})\n        \n        # Output to stdout for Git to capture\n        sys.stdout.write(result)\n    except Exception as e:\n        # On error, return the original content\n        with open(file_path, \"rb\") as f:\n            sys.stdout.buffer.write(f.read())\n\n\ndef smudge_filter(file_path):\n    \"\"\"Git smudge filter to decrypt a file (used by Git during checkout).\"\"\"\n    sk = create_or_read_secret_key()\n    try:\n        # Read from stdin (Git provides the content)\n        content = sys.stdin.buffer.read()\n        \n        # Try to parse as JSON\n        try:\n            # Try to decode as text\n            text_content = content.decode('utf-8')\n            data = json.loads(text_content)\n            \n            # Check if it's our encrypted format\n            if \"nonce\" in data and \"ciphertext\" in data:\n                nonce = b64decode(data[\"nonce\"])\n                ciphertext = b64decode(data[\"ciphertext\"])\n                cipher = AES.new(sk, AES.MODE_CTR, nonce=nonce)\n                decrypted = cipher.decrypt(ciphertext)\n                sys.stdout.buffer.write(decrypted)\n                return\n        except (UnicodeDecodeError, json.JSONDecodeError, KeyError, ValueError):\n            # Not our format or not valid JSON, continue\n            pass\n        \n        # If we get here, it's not encrypted or not in our format\n        sys.stdout.buffer.write(content)\n    except Exception as e:\n        # On error, return the input unchanged\n        sys.stdout.buffer.write(content)\n```\n\nAlso, create a module `eval_crypt/filters.py` to handle the filter logic separately from the CLI. These functions will be used internally by the Git filter integration:\n\n```python\nfrom Crypto.Cipher import AES\nfrom base64 import b64encode, b64decode\nimport json\nfrom typing import Union, Tuple, Optional\n\n\ndef is_encrypted(content: bytes) -> bool:\n    \"\"\"Check if content is already in our encrypted format.\"\"\"\n    try:\n        data = json.loads(content.decode('utf-8'))\n        return \"nonce\" in data and \"ciphertext\" in data\n    except (UnicodeDecodeError, json.JSONDecodeError):\n        return False\n\n\ndef encrypt_content(content: bytes, secret_key: bytes) -> bytes:\n    \"\"\"Encrypt content using AES encryption.\"\"\"\n    if is_encrypted(content):\n        return content  # Already encrypted\n    \n    cipher = AES.new(secret_key, AES.MODE_CTR)\n    encrypted = cipher.encrypt(content)\n    nonce = b64encode(cipher.nonce).decode(\"utf-8\")\n    ct = b64encode(encrypted).decode(\"utf-8\")\n    result = json.dumps({\"nonce\": nonce, \"ciphertext\": ct})\n    \n    return result.encode('utf-8')\n\n\ndef decrypt_content(content: bytes, secret_key: bytes) -> bytes:\n    \"\"\"Decrypt content that was encrypted using encrypt_content.\"\"\"\n    if not is_encrypted(content):\n        return content  # Not encrypted or not in our format\n    \n    data = json.loads(content.decode('utf-8'))\n    nonce = b64decode(data[\"nonce\"])\n    ciphertext = b64decode(data[\"ciphertext\"])\n    cipher = AES.new(secret_key, AES.MODE_CTR, nonce=nonce)\n    decrypted = cipher.decrypt(ciphertext)\n    \n    return decrypted\n```",
        "testStrategy": "Create unit tests for the filter functions. Test encrypting and decrypting content with various types (text, binary). Test handling of content that is already encrypted. Test the clean and smudge filter functions by mocking stdin and stdout. Verify that the functions correctly process files during Git operations. Ensure that these functions are not exposed as user-facing CLI commands but are properly integrated with Git filters.",
        "subtasks": []
      },
      {
        "id": 8,
        "title": "Create Documentation",
        "description": "Create comprehensive documentation for the eval-crypt package, including installation, usage, and examples.",
        "details": "Create documentation files in the docs/ directory:\n\n1. Create a comprehensive README.md in the project root:\n```markdown\n# eval-crypt\n\nA Python package that encrypts sensitive AI safety evaluation files in Git repositories to prevent models from memorizing solutions during pre-training.\n\n## Problem\n\nAI safety researchers often publish evaluation code and data to GitHub. If these repositories are later crawled for model pre-training, the models could memorize solutions to the evaluations, making them less effective at measuring emergent capabilities.\n\n## Solution\n\neval-crypt encrypts sensitive files before they are pushed to GitHub and decrypts them when pulled, allowing researchers to work with plaintext files locally while ensuring the public repository contains only encrypted versions.\n\n## Installation\n\n```bash\npip install eval-crypt\n```\n\n## Quick Start\n\n1. Initialize eval-crypt in your repository:\n\n```bash\neval-crypt init\n```\n\n2. Add sensitive files to be encrypted:\n\n```bash\neval-crypt add sensitive_file.txt\neval-crypt add \"*.json\"  # Use quotes for patterns with wildcards\n```\n\n3. Continue using Git normally. Files will be automatically encrypted on commit and decrypted on pull.\n\n## Commands\n\n- `eval-crypt init`: Initialize eval-crypt in the current repository\n- `eval-crypt add <file_pattern>`: Add a file pattern to the list of sensitive files\n- `eval-crypt remove <file_pattern>`: Remove a file pattern from the list of sensitive files\n- `eval-crypt list`: List all sensitive file patterns\n- `eval-crypt encrypt`: Manually encrypt all sensitive files\n- `eval-crypt decrypt`: Manually decrypt all sensitive files\n\n## How It Works\n\neval-crypt uses Git filters and hooks to automatically encrypt and decrypt files:\n\n1. When you add a file pattern with `eval-crypt add`, it's added to `.gitattributes` with the `filter=eval-crypt` attribute\n2. The pre-commit hook encrypts sensitive files before they're committed\n3. The post-merge hook decrypts sensitive files after they're pulled\n\nEven if a model is pre-trained on both the encrypted files and the encryption key, it won't be able to run the decryption algorithm during pre-training, so the sensitive content remains protected.\n\n## Contributing\n\nContributions are welcome! Please feel free to submit a Pull Request.\n```\n\n2. Create a detailed usage guide in docs/usage.md:\n```markdown\n# eval-crypt Usage Guide\n\n## Installation\n\nInstall eval-crypt using pip:\n\n```bash\npip install eval-crypt\n```\n\n## Repository Setup\n\n### Initializing eval-crypt\n\nIn your Git repository, run:\n\n```bash\neval-crypt init\n```\n\nThis will:\n- Generate a secret key (stored in `anti-pretraining.sk`)\n- Configure Git filters\n- Install Git hooks\n\n### Managing Sensitive Files\n\n#### Adding Files\n\nTo add a file or pattern to the list of sensitive files:\n\n```bash\neval-crypt add sensitive_file.txt\n```\n\nYou can use patterns to match multiple files:\n\n```bash\neval-crypt add \"*.json\"\neval-crypt add \"data/*.csv\"\n```\n\n#### Removing Files\n\nTo remove a file or pattern from the list:\n\n```bash\neval-crypt remove sensitive_file.txt\n```\n\n#### Listing Files\n\nTo see all sensitive file patterns:\n\n```bash\neval-crypt list\n```\n\n## Working with Git\n\n### Normal Workflow\n\nOnce set up, you can use Git normally. The hooks will automatically:\n- Encrypt sensitive files when you commit (pre-commit hook)\n- Decrypt sensitive files when you pull or merge (post-merge hook)\n\n### Manual Encryption/Decryption\n\nIf needed, you can manually encrypt or decrypt files:\n\n```bash\neval-crypt encrypt  # Encrypt all sensitive files\neval-crypt decrypt  # Decrypt all sensitive files\n```\n\n## Troubleshooting\n\n### Files Not Encrypting\n\nIf files aren't being encrypted on commit:\n\n1. Check if the file pattern is in the sensitive files list: `eval-crypt list`\n2. Verify Git hooks are installed correctly\n3. Try manual encryption: `eval-crypt encrypt`\n\n### Files Not Decrypting\n\nIf files aren't being decrypted on pull:\n\n1. Check if the encrypted file exists (`.enc` extension)\n2. Verify the secret key is present and correct\n3. Try manual decryption: `eval-crypt decrypt`\n```\n\n3. Create a technical reference in docs/technical.md:\n```markdown\n# Technical Reference\n\n## Architecture\n\neval-crypt consists of several components:\n\n1. **Crypto Module**: Handles encryption and decryption using AES\n2. **Git Attributes Manager**: Manages the `.gitattributes` file\n3. **Git Filter Scripts**: Implements the clean and smudge filters\n4. **Git Hooks**: Pre-commit and post-merge hooks\n5. **CLI**: Command-line interface for user interaction\n\n## Encryption Details\n\neval-crypt uses AES encryption in CTR mode:\n\n- A 16-byte secret key is generated and stored in `anti-pretraining.sk`\n- Files are encrypted with a unique nonce for each encryption\n- Encrypted data is stored as a JSON object with nonce and ciphertext\n\n## Git Integration\n\n### Filters\n\nGit filters are configured in the repository's `.git/config`:\n\n```\n[filter \"eval-crypt\"]\n    clean = eval-crypt clean %f\n    smudge = eval-crypt smudge %f\n    required = true\n```\n\n- The **clean** filter runs during staging and encrypts files\n- The **smudge** filter runs during checkout and decrypts files\n\n### Attributes\n\nSensitive files are marked in `.gitattributes` with the `filter=eval-crypt` attribute:\n\n```\nsensitive_file.txt filter=eval-crypt\n*.json filter=eval-crypt\n```\n\n### Hooks\n\n- **Pre-commit**: Encrypts sensitive files before commit\n- **Post-merge**: Decrypts sensitive files after merge\n\n## File Format\n\nEncrypted files are stored as JSON objects:\n\n```json\n{\n    \"nonce\": \"base64-encoded-nonce\",\n    \"ciphertext\": \"base64-encoded-encrypted-data\"\n}\n```\n```",
        "testStrategy": "Review the documentation for accuracy, completeness, and clarity. Ensure all commands and examples are correct. Verify that the installation instructions work on a fresh environment. Check that the technical details accurately reflect the implementation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 9,
        "title": "Implement Testing Suite",
        "description": "Create a comprehensive testing suite to ensure the functionality of eval-crypt.",
        "details": "Create test files in the tests/ directory:\n\n1. Create `tests/test_crypto.py`:\n```python\nimport os\nimport json\nimport tempfile\nfrom pathlib import Path\nimport pytest\n\nfrom eval_crypt.crypto import create_or_read_secret_key, encrypt_file, decrypt_file\n\n\ndef test_create_or_read_secret_key():\n    # Test creating a new key\n    with tempfile.TemporaryDirectory() as tmpdir:\n        key_path = Path(tmpdir) / \"test.sk\"\n        key = create_or_read_secret_key(key_path)\n        assert len(key) == 16\n        assert key_path.exists()\n        \n        # Test reading existing key\n        key2 = create_or_read_secret_key(key_path)\n        assert key == key2\n\n\ndef test_encrypt_decrypt_file():\n    # Test encrypting and decrypting a text file\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a test file\n        file_path = Path(tmpdir) / \"test.txt\"\n        test_content = \"This is a test file with sensitive content.\"\n        with open(file_path, \"w\") as f:\n            f.write(test_content)\n        \n        # Create a key\n        key_path = Path(tmpdir) / \"test.sk\"\n        key = create_or_read_secret_key(key_path)\n        \n        # Encrypt the file\n        encrypt_file(file_path, key)\n        \n        # Check that original file is gone and encrypted file exists\n        assert not file_path.exists()\n        assert (file_path.with_suffix(file_path.suffix + \".enc\")).exists()\n        \n        # Check that encrypted file contains valid JSON with nonce and ciphertext\n        with open(file_path.with_suffix(file_path.suffix + \".enc\"), \"r\") as f:\n            encrypted_data = json.loads(f.read())\n            assert \"nonce\" in encrypted_data\n            assert \"ciphertext\" in encrypted_data\n        \n        # Decrypt the file\n        decrypt_file(file_path, key)\n        \n        # Check that encrypted file is gone and original file is back\n        assert file_path.exists()\n        assert not (file_path.with_suffix(file_path.suffix + \".enc\")).exists()\n        \n        # Check that content is preserved\n        with open(file_path, \"r\") as f:\n            decrypted_content = f.read()\n            assert decrypted_content == test_content\n\n\ndef test_encrypt_decrypt_binary_file():\n    # Test encrypting and decrypting a binary file\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a test binary file\n        file_path = Path(tmpdir) / \"test.bin\"\n        test_content = os.urandom(1024)  # 1KB of random bytes\n        with open(file_path, \"wb\") as f:\n            f.write(test_content)\n        \n        # Create a key\n        key_path = Path(tmpdir) / \"test.sk\"\n        key = create_or_read_secret_key(key_path)\n        \n        # Encrypt and decrypt\n        encrypt_file(file_path, key)\n        decrypt_file(file_path, key)\n        \n        # Check that content is preserved\n        with open(file_path, \"rb\") as f:\n            decrypted_content = f.read()\n            assert decrypted_content == test_content\n\n\ndef test_file_not_found():\n    # Test handling of non-existent files\n    with tempfile.TemporaryDirectory() as tmpdir:\n        key_path = Path(tmpdir) / \"test.sk\"\n        key = create_or_read_secret_key(key_path)\n        \n        non_existent_file = Path(tmpdir) / \"does_not_exist.txt\"\n        with pytest.raises(FileNotFoundError):\n            encrypt_file(non_existent_file, key)\n        \n        with pytest.raises(FileNotFoundError):\n            decrypt_file(non_existent_file, key)\n```\n\n2. Create `tests/test_gitattributes.py`:\n```python\nimport tempfile\nfrom pathlib import Path\n\nfrom eval_crypt.gitattributes import add_sensitive_file, remove_sensitive_file, get_sensitive_files\n\n\ndef test_add_sensitive_file():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        gitattributes_path = Path(tmpdir) / \".gitattributes\"\n        \n        # Test adding a file\n        add_sensitive_file(\"test.txt\", gitattributes_path)\n        assert gitattributes_path.exists()\n        \n        with open(gitattributes_path, \"r\") as f:\n            content = f.read()\n            assert \"test.txt filter=eval-crypt\" in content\n        \n        # Test adding a second file\n        add_sensitive_file(\"*.json\", gitattributes_path)\n        with open(gitattributes_path, \"r\") as f:\n            content = f.read()\n            assert \"test.txt filter=eval-crypt\" in content\n            assert \"*.json filter=eval-crypt\" in content\n        \n        # Test adding a duplicate (should not add)\n        add_sensitive_file(\"test.txt\", gitattributes_path)\n        with open(gitattributes_path, \"r\") as f:\n            content = f.read().splitlines()\n            assert len([line for line in content if \"test.txt filter=eval-crypt\" in line]) == 1\n\n\ndef test_remove_sensitive_file():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        gitattributes_path = Path(tmpdir) / \".gitattributes\"\n        \n        # Add some files\n        add_sensitive_file(\"test.txt\", gitattributes_path)\n        add_sensitive_file(\"*.json\", gitattributes_path)\n        \n        # Test removing a file\n        result = remove_sensitive_file(\"test.txt\", gitattributes_path)\n        assert result is True\n        \n        with open(gitattributes_path, \"r\") as f:\n            content = f.read()\n            assert \"test.txt filter=eval-crypt\" not in content\n            assert \"*.json filter=eval-crypt\" in content\n        \n        # Test removing a non-existent file\n        result = remove_sensitive_file(\"does_not_exist.txt\", gitattributes_path)\n        assert result is False\n\n\ndef test_get_sensitive_files():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        gitattributes_path = Path(tmpdir) / \".gitattributes\"\n        \n        # Test with no files\n        files = get_sensitive_files(gitattributes_path)\n        assert files == []\n        \n        # Add some files\n        add_sensitive_file(\"test.txt\", gitattributes_path)\n        add_sensitive_file(\"*.json\", gitattributes_path)\n        \n        # Test getting files\n        files = get_sensitive_files(gitattributes_path)\n        assert \"test.txt\" in files\n        assert \"*.json\" in files\n        assert len(files) == 2\n```\n\n3. Create `tests/test_cli.py`:\n```python\nimport tempfile\nfrom pathlib import Path\nimport os\nimport subprocess\nfrom click.testing import CliRunner\n\nfrom eval_crypt.cli import cli\n\n\ndef test_init_command():\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        # Initialize a Git repository\n        subprocess.run([\"git\", \"init\"], check=True)\n        \n        # Run init command\n        result = runner.invoke(cli, [\"init\"])\n        assert result.exit_code == 0\n        \n        # Check that key file was created\n        assert Path(\"anti-pretraining.sk\").exists()\n        \n        # Check that Git hooks were installed\n        assert Path(\".git/hooks/pre-commit\").exists()\n        assert Path(\".git/hooks/post-merge\").exists()\n\n\ndef test_add_remove_list_commands():\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        # Initialize a Git repository\n        subprocess.run([\"git\", \"init\"], check=True)\n        \n        # Run init command\n        runner.invoke(cli, [\"init\"])\n        \n        # Add a file\n        result = runner.invoke(cli, [\"add\", \"test.txt\"])\n        assert result.exit_code == 0\n        assert \"Added test.txt to sensitive files\" in result.output\n        \n        # List files\n        result = runner.invoke(cli, [\"list\"])\n        assert result.exit_code == 0\n        assert \"test.txt\" in result.output\n        \n        # Add another file\n        result = runner.invoke(cli, [\"add\", \"*.json\"])\n        assert result.exit_code == 0\n        \n        # List files again\n        result = runner.invoke(cli, [\"list\"])\n        assert result.exit_code == 0\n        assert \"test.txt\" in result.output\n        assert \"*.json\" in result.output\n        \n        # Remove a file\n        result = runner.invoke(cli, [\"remove\", \"test.txt\"])\n        assert result.exit_code == 0\n        assert \"Removed test.txt from sensitive files\" in result.output\n        \n        # List files after removal\n        result = runner.invoke(cli, [\"list\"])\n        assert result.exit_code == 0\n        assert \"test.txt\" not in result.output\n        assert \"*.json\" in result.output\n\n\ndef test_encrypt_decrypt_commands():\n    runner = CliRunner()\n    with runner.isolated_filesystem():\n        # Initialize a Git repository\n        subprocess.run([\"git\", \"init\"], check=True)\n        \n        # Run init command\n        runner.invoke(cli, [\"init\"])\n        \n        # Create a test file\n        with open(\"test.txt\", \"w\") as f:\n            f.write(\"This is a test file.\")\n        \n        # Add the file to sensitive files\n        runner.invoke(cli, [\"add\", \"test.txt\"])\n        \n        # Encrypt the file\n        result = runner.invoke(cli, [\"encrypt\"])\n        assert result.exit_code == 0\n        assert \"Encrypted test.txt\" in result.output\n        \n        # Check that original file is gone and encrypted file exists\n        assert not Path(\"test.txt\").exists()\n        assert Path(\"test.txt.enc\").exists()\n        \n        # Decrypt the file\n        result = runner.invoke(cli, [\"decrypt\"])\n        assert result.exit_code == 0\n        assert \"Decrypted test.txt\" in result.output\n        \n        # Check that encrypted file is gone and original file is back\n        assert Path(\"test.txt\").exists()\n        assert not Path(\"test.txt.enc\").exists()\n        \n        # Check that content is preserved\n        with open(\"test.txt\", \"r\") as f:\n            content = f.read()\n            assert content == \"This is a test file.\"\n```\n\n4. Create `tests/test_filters.py`:\n```python\nimport tempfile\nfrom pathlib import Path\nimport json\nfrom base64 import b64encode\n\nfrom eval_crypt.filters import is_encrypted, encrypt_content, decrypt_content\nfrom eval_crypt.crypto import create_or_read_secret_key\n\n\ndef test_is_encrypted():\n    # Test with non-encrypted content\n    content = b\"This is not encrypted\"\n    assert not is_encrypted(content)\n    \n    # Test with encrypted content\n    encrypted_data = {\"nonce\": \"abc\", \"ciphertext\": \"xyz\"}\n    encrypted_content = json.dumps(encrypted_data).encode('utf-8')\n    assert is_encrypted(encrypted_content)\n    \n    # Test with invalid JSON\n    invalid_json = b\"{not valid json\"\n    assert not is_encrypted(invalid_json)\n    \n    # Test with binary data\n    binary_data = bytes([0, 1, 2, 3, 4])\n    assert not is_encrypted(binary_data)\n\n\ndef test_encrypt_decrypt_content():\n    # Create a secret key\n    with tempfile.TemporaryDirectory() as tmpdir:\n        key_path = Path(tmpdir) / \"test.sk\"\n        key = create_or_read_secret_key(key_path)\n        \n        # Test with text content\n        content = b\"This is a test message.\"\n        encrypted = encrypt_content(content, key)\n        \n        # Verify it's in our format\n        assert is_encrypted(encrypted)\n        \n        # Decrypt and verify\n        decrypted = decrypt_content(encrypted, key)\n        assert decrypted == content\n        \n        # Test with binary content\n        binary_content = bytes(range(256))  # All byte values 0-255\n        encrypted = encrypt_content(binary_content, key)\n        decrypted = decrypt_content(encrypted, key)\n        assert decrypted == binary_content\n        \n        # Test with already encrypted content\n        double_encrypted = encrypt_content(encrypted, key)\n        assert double_encrypted == encrypted  # Should not re-encrypt\n        \n        # Test with non-encrypted content for decrypt\n        non_encrypted = b\"Not encrypted\"\n        result = decrypt_content(non_encrypted, key)\n        assert result == non_encrypted  # Should return as-is\n```\n\n5. Create `tests/test_hooks.py`:\n```python\nimport tempfile\nfrom pathlib import Path\nimport os\nimport stat\nimport subprocess\n\nfrom eval_crypt.hooks import install_hooks, check_hooks_installed\n\n\ndef test_install_hooks():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a fake .git/hooks directory\n        hooks_dir = Path(tmpdir) / \".git\" / \"hooks\"\n        hooks_dir.mkdir(parents=True)\n        \n        # Install hooks\n        result = install_hooks(tmpdir)\n        assert result is True\n        \n        # Check that hooks were created\n        pre_commit_path = hooks_dir / \"pre-commit\"\n        post_merge_path = hooks_dir / \"post-merge\"\n        assert pre_commit_path.exists()\n        assert post_merge_path.exists()\n        \n        # Check that hooks are executable\n        assert os.access(pre_commit_path, os.X_OK)\n        assert os.access(post_merge_path, os.X_OK)\n        \n        # Check hook content\n        with open(pre_commit_path, \"r\") as f:\n            pre_commit_content = f.read()\n            assert \"eval-crypt encrypt\" in pre_commit_content\n        \n        with open(post_merge_path, \"r\") as f:\n            post_merge_content = f.read()\n            assert \"eval-crypt decrypt\" in post_merge_content\n\n\ndef test_check_hooks_installed():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Create a fake .git/hooks directory\n        hooks_dir = Path(tmpdir) / \".git\" / \"hooks\"\n        hooks_dir.mkdir(parents=True)\n        \n        # Check before installation\n        assert not check_hooks_installed(tmpdir)\n        \n        # Install hooks\n        install_hooks(tmpdir)\n        \n        # Check after installation\n        assert check_hooks_installed(tmpdir)\n        \n        # Modify a hook to not contain eval-crypt\n        with open(hooks_dir / \"pre-commit\", \"w\") as f:\n            f.write(\"#!/bin/sh\\nexit 0\\n\")\n        \n        # Check should now fail\n        assert not check_hooks_installed(tmpdir)\n```\n\n6. Create `tests/test_git_config.py`:\n```python\nimport tempfile\nfrom pathlib import Path\nimport subprocess\n\nfrom eval_crypt.git_config import configure_git_filters, check_git_filters_configured\n\n\ndef test_git_filter_configuration():\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Initialize a Git repository\n        repo_path = Path(tmpdir)\n        subprocess.run([\"git\", \"init\"], cwd=repo_path, check=True)\n        \n        # Check before configuration\n        assert not check_git_filters_configured(repo_path)\n        \n        # Configure filters\n        result = configure_git_filters(repo_path)\n        assert result is True\n        \n        # Check after configuration\n        assert check_git_filters_configured(repo_path)\n        \n        # Verify filter settings\n        clean_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.clean\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        assert \"eval-crypt clean\" in clean_result.stdout\n        \n        smudge_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.smudge\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        assert \"eval-crypt smudge\" in smudge_result.stdout\n        \n        required_result = subprocess.run(\n            [\"git\", \"config\", \"--get\", \"filter.eval-crypt.required\"],\n            cwd=repo_path,\n            capture_output=True,\n            text=True,\n        )\n        assert \"true\" in required_result.stdout\n```\n\n7. Create `tests/conftest.py` for shared test fixtures:\n```python\nimport pytest\nimport tempfile\nimport os\nimport subprocess\nfrom pathlib import Path\n\n\n@pytest.fixture\ndef git_repo():\n    \"\"\"Create a temporary Git repository for testing.\"\"\"\n    with tempfile.TemporaryDirectory() as tmpdir:\n        # Initialize Git repository\n        subprocess.run([\"git\", \"init\"], cwd=tmpdir, check=True)\n        \n        # Configure Git user for commits\n        subprocess.run([\"git\", \"config\", \"user.name\", \"Test User\"], cwd=tmpdir, check=True)\n        subprocess.run([\"git\", \"config\", \"user.email\", \"test@example.com\"], cwd=tmpdir, check=True)\n        \n        yield Path(tmpdir)\n```",
        "testStrategy": "Run the test suite with pytest to verify all functionality. Ensure tests cover all core functionality, edge cases, and error handling. Use code coverage tools to identify any untested code paths. Test on different operating systems (Windows, macOS, Linux) to ensure cross-platform compatibility.",
        "priority": "high",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": 10,
        "title": "Package and Publish to PyPI",
        "description": "Prepare the package for distribution and publish it to PyPI for easy installation.",
        "details": "Complete the following steps to package and publish eval-crypt to PyPI:\n\n1. Ensure the package structure is correct:\n```\neval-crypt/\n├── eval_crypt/\n│   ├── __init__.py\n│   ├── cli.py\n│   ├── crypto.py\n│   ├── filters.py\n│   ├── git_config.py\n│   ├── gitattributes.py\n│   └── hooks.py\n├── tests/\n│   ├── conftest.py\n│   ├── test_cli.py\n│   ├── test_crypto.py\n│   ├── test_filters.py\n│   ├── test_git_config.py\n│   ├── test_gitattributes.py\n│   └── test_hooks.py\n├── docs/\n│   ├── technical.md\n│   └── usage.md\n├── .gitignore\n├── LICENSE\n├── pyproject.toml\n└── README.md\n```\n\n2. Update `__init__.py` to expose the package version and main functions:\n```python\n\"\"\"eval-crypt: Encrypt sensitive AI safety evaluation files in Git repositories.\"\"\"\n\n__version__ = \"0.1.0\"\n\nfrom eval_crypt.crypto import create_or_read_secret_key, encrypt_file, decrypt_file\nfrom eval_crypt.gitattributes import add_sensitive_file, remove_sensitive_file, get_sensitive_files\nfrom eval_crypt.git_config import configure_git_filters, check_git_filters_configured\nfrom eval_crypt.hooks import install_hooks, check_hooks_installed\n```\n\n3. Create a `.gitignore` file:\n```\n# Python\n__pycache__/\n*.py[cod]\n*$py.class\n*.so\n.Python\nbuild/\ndevelop-eggs/\ndist/\ndownloads/\neggs/\n.eggs/\nlib/\nlib64/\nparts/\nsdist/\nvar/\nwheels/\n*.egg-info/\n.installed.cfg\n*.egg\n\n# Virtual environments\nvenv/\nenv/\nENV/\n\n# Testing\n.pytest_cache/\n.coverage\nhtmlcov/\n\n# Secret key\nanti-pretraining.sk\n```\n\n4. Create a `LICENSE` file (MIT License):\n```\nMIT License\n\nCopyright (c) 2023 eval-crypt Contributors\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in all\ncopies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\nSOFTWARE.\n```\n\n5. Build the package:\n```bash\npython -m pip install --upgrade build\npython -m build\n```\n\n6. Test the package locally:\n```bash\npython -m pip install --editable .\n```\n\n7. Create a PyPI account if you don't have one.\n\n8. Install twine for uploading to PyPI:\n```bash\npython -m pip install --upgrade twine\n```\n\n9. Upload to TestPyPI first to verify everything works:\n```bash\npython -m twine upload --repository testpypi dist/*\n```\n\n10. Test installation from TestPyPI:\n```bash\npython -m pip install --index-url https://test.pypi.org/simple/ eval-crypt\n```\n\n11. Upload to the real PyPI:\n```bash\npython -m twine upload dist/*\n```\n\n12. Verify installation from PyPI:\n```bash\npython -m pip install eval-crypt\n```\n\n13. Create a GitHub repository for the project and push the code:\n```bash\ngit init\ngit add .\ngit commit -m \"Initial commit\"\ngit remote add origin https://github.com/yourusername/eval-crypt.git\ngit push -u origin main\n```",
        "testStrategy": "Test the package installation from both TestPyPI and PyPI. Verify that the package can be installed with pip and that all commands work correctly after installation. Test in a clean virtual environment to ensure all dependencies are correctly specified. Verify that the entry points are correctly configured and that the eval-crypt command is available after installation.",
        "priority": "medium",
        "dependencies": [
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "created": "2025-07-10T10:23:51.578Z",
      "updated": "2025-07-10T12:53:34.697Z",
      "description": "Tasks for master context"
    }
  }
}
# Task ID: 9
# Title: Implement Testing Suite
# Status: pending
# Dependencies: 1, 2, 3, 4, 5, 6, 7
# Priority: high
# Description: Create a comprehensive testing suite to ensure the functionality of eval-crypt.
# Details:
Create test files in the tests/ directory:

1. Create `tests/test_crypto.py`:
```python
import os
import json
import tempfile
from pathlib import Path
import pytest

from eval_crypt.crypto import create_or_read_secret_key, encrypt_file, decrypt_file


def test_create_or_read_secret_key():
    # Test creating a new key
    with tempfile.TemporaryDirectory() as tmpdir:
        key_path = Path(tmpdir) / "test.sk"
        key = create_or_read_secret_key(key_path)
        assert len(key) == 16
        assert key_path.exists()
        
        # Test reading existing key
        key2 = create_or_read_secret_key(key_path)
        assert key == key2


def test_encrypt_decrypt_file():
    # Test encrypting and decrypting a text file
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a test file
        file_path = Path(tmpdir) / "test.txt"
        test_content = "This is a test file with sensitive content."
        with open(file_path, "w") as f:
            f.write(test_content)
        
        # Create a key
        key_path = Path(tmpdir) / "test.sk"
        key = create_or_read_secret_key(key_path)
        
        # Encrypt the file
        encrypt_file(file_path, key)
        
        # Check that original file is gone and encrypted file exists
        assert not file_path.exists()
        assert (file_path.with_suffix(file_path.suffix + ".enc")).exists()
        
        # Check that encrypted file contains valid JSON with nonce and ciphertext
        with open(file_path.with_suffix(file_path.suffix + ".enc"), "r") as f:
            encrypted_data = json.loads(f.read())
            assert "nonce" in encrypted_data
            assert "ciphertext" in encrypted_data
        
        # Decrypt the file
        decrypt_file(file_path, key)
        
        # Check that encrypted file is gone and original file is back
        assert file_path.exists()
        assert not (file_path.with_suffix(file_path.suffix + ".enc")).exists()
        
        # Check that content is preserved
        with open(file_path, "r") as f:
            decrypted_content = f.read()
            assert decrypted_content == test_content


def test_encrypt_decrypt_binary_file():
    # Test encrypting and decrypting a binary file
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a test binary file
        file_path = Path(tmpdir) / "test.bin"
        test_content = os.urandom(1024)  # 1KB of random bytes
        with open(file_path, "wb") as f:
            f.write(test_content)
        
        # Create a key
        key_path = Path(tmpdir) / "test.sk"
        key = create_or_read_secret_key(key_path)
        
        # Encrypt and decrypt
        encrypt_file(file_path, key)
        decrypt_file(file_path, key)
        
        # Check that content is preserved
        with open(file_path, "rb") as f:
            decrypted_content = f.read()
            assert decrypted_content == test_content


def test_file_not_found():
    # Test handling of non-existent files
    with tempfile.TemporaryDirectory() as tmpdir:
        key_path = Path(tmpdir) / "test.sk"
        key = create_or_read_secret_key(key_path)
        
        non_existent_file = Path(tmpdir) / "does_not_exist.txt"
        with pytest.raises(FileNotFoundError):
            encrypt_file(non_existent_file, key)
        
        with pytest.raises(FileNotFoundError):
            decrypt_file(non_existent_file, key)
```

2. Create `tests/test_gitattributes.py`:
```python
import tempfile
from pathlib import Path

from eval_crypt.gitattributes import add_sensitive_file, remove_sensitive_file, get_sensitive_files


def test_add_sensitive_file():
    with tempfile.TemporaryDirectory() as tmpdir:
        gitattributes_path = Path(tmpdir) / ".gitattributes"
        
        # Test adding a file
        add_sensitive_file("test.txt", gitattributes_path)
        assert gitattributes_path.exists()
        
        with open(gitattributes_path, "r") as f:
            content = f.read()
            assert "test.txt filter=eval-crypt" in content
        
        # Test adding a second file
        add_sensitive_file("*.json", gitattributes_path)
        with open(gitattributes_path, "r") as f:
            content = f.read()
            assert "test.txt filter=eval-crypt" in content
            assert "*.json filter=eval-crypt" in content
        
        # Test adding a duplicate (should not add)
        add_sensitive_file("test.txt", gitattributes_path)
        with open(gitattributes_path, "r") as f:
            content = f.read().splitlines()
            assert len([line for line in content if "test.txt filter=eval-crypt" in line]) == 1


def test_remove_sensitive_file():
    with tempfile.TemporaryDirectory() as tmpdir:
        gitattributes_path = Path(tmpdir) / ".gitattributes"
        
        # Add some files
        add_sensitive_file("test.txt", gitattributes_path)
        add_sensitive_file("*.json", gitattributes_path)
        
        # Test removing a file
        result = remove_sensitive_file("test.txt", gitattributes_path)
        assert result is True
        
        with open(gitattributes_path, "r") as f:
            content = f.read()
            assert "test.txt filter=eval-crypt" not in content
            assert "*.json filter=eval-crypt" in content
        
        # Test removing a non-existent file
        result = remove_sensitive_file("does_not_exist.txt", gitattributes_path)
        assert result is False


def test_get_sensitive_files():
    with tempfile.TemporaryDirectory() as tmpdir:
        gitattributes_path = Path(tmpdir) / ".gitattributes"
        
        # Test with no files
        files = get_sensitive_files(gitattributes_path)
        assert files == []
        
        # Add some files
        add_sensitive_file("test.txt", gitattributes_path)
        add_sensitive_file("*.json", gitattributes_path)
        
        # Test getting files
        files = get_sensitive_files(gitattributes_path)
        assert "test.txt" in files
        assert "*.json" in files
        assert len(files) == 2
```

3. Create `tests/test_cli.py`:
```python
import tempfile
from pathlib import Path
import os
import subprocess
from click.testing import CliRunner

from eval_crypt.cli import cli


def test_init_command():
    runner = CliRunner()
    with runner.isolated_filesystem():
        # Initialize a Git repository
        subprocess.run(["git", "init"], check=True)
        
        # Run init command
        result = runner.invoke(cli, ["init"])
        assert result.exit_code == 0
        
        # Check that key file was created
        assert Path("anti-pretraining.sk").exists()
        
        # Check that Git hooks were installed
        assert Path(".git/hooks/pre-commit").exists()
        assert Path(".git/hooks/post-merge").exists()


def test_add_remove_list_commands():
    runner = CliRunner()
    with runner.isolated_filesystem():
        # Initialize a Git repository
        subprocess.run(["git", "init"], check=True)
        
        # Run init command
        runner.invoke(cli, ["init"])
        
        # Add a file
        result = runner.invoke(cli, ["add", "test.txt"])
        assert result.exit_code == 0
        assert "Added test.txt to sensitive files" in result.output
        
        # List files
        result = runner.invoke(cli, ["list"])
        assert result.exit_code == 0
        assert "test.txt" in result.output
        
        # Add another file
        result = runner.invoke(cli, ["add", "*.json"])
        assert result.exit_code == 0
        
        # List files again
        result = runner.invoke(cli, ["list"])
        assert result.exit_code == 0
        assert "test.txt" in result.output
        assert "*.json" in result.output
        
        # Remove a file
        result = runner.invoke(cli, ["remove", "test.txt"])
        assert result.exit_code == 0
        assert "Removed test.txt from sensitive files" in result.output
        
        # List files after removal
        result = runner.invoke(cli, ["list"])
        assert result.exit_code == 0
        assert "test.txt" not in result.output
        assert "*.json" in result.output


def test_encrypt_decrypt_commands():
    runner = CliRunner()
    with runner.isolated_filesystem():
        # Initialize a Git repository
        subprocess.run(["git", "init"], check=True)
        
        # Run init command
        runner.invoke(cli, ["init"])
        
        # Create a test file
        with open("test.txt", "w") as f:
            f.write("This is a test file.")
        
        # Add the file to sensitive files
        runner.invoke(cli, ["add", "test.txt"])
        
        # Encrypt the file
        result = runner.invoke(cli, ["encrypt"])
        assert result.exit_code == 0
        assert "Encrypted test.txt" in result.output
        
        # Check that original file is gone and encrypted file exists
        assert not Path("test.txt").exists()
        assert Path("test.txt.enc").exists()
        
        # Decrypt the file
        result = runner.invoke(cli, ["decrypt"])
        assert result.exit_code == 0
        assert "Decrypted test.txt" in result.output
        
        # Check that encrypted file is gone and original file is back
        assert Path("test.txt").exists()
        assert not Path("test.txt.enc").exists()
        
        # Check that content is preserved
        with open("test.txt", "r") as f:
            content = f.read()
            assert content == "This is a test file."
```

4. Create `tests/test_filters.py`:
```python
import tempfile
from pathlib import Path
import json
from base64 import b64encode

from eval_crypt.filters import is_encrypted, encrypt_content, decrypt_content
from eval_crypt.crypto import create_or_read_secret_key


def test_is_encrypted():
    # Test with non-encrypted content
    content = b"This is not encrypted"
    assert not is_encrypted(content)
    
    # Test with encrypted content
    encrypted_data = {"nonce": "abc", "ciphertext": "xyz"}
    encrypted_content = json.dumps(encrypted_data).encode('utf-8')
    assert is_encrypted(encrypted_content)
    
    # Test with invalid JSON
    invalid_json = b"{not valid json"
    assert not is_encrypted(invalid_json)
    
    # Test with binary data
    binary_data = bytes([0, 1, 2, 3, 4])
    assert not is_encrypted(binary_data)


def test_encrypt_decrypt_content():
    # Create a secret key
    with tempfile.TemporaryDirectory() as tmpdir:
        key_path = Path(tmpdir) / "test.sk"
        key = create_or_read_secret_key(key_path)
        
        # Test with text content
        content = b"This is a test message."
        encrypted = encrypt_content(content, key)
        
        # Verify it's in our format
        assert is_encrypted(encrypted)
        
        # Decrypt and verify
        decrypted = decrypt_content(encrypted, key)
        assert decrypted == content
        
        # Test with binary content
        binary_content = bytes(range(256))  # All byte values 0-255
        encrypted = encrypt_content(binary_content, key)
        decrypted = decrypt_content(encrypted, key)
        assert decrypted == binary_content
        
        # Test with already encrypted content
        double_encrypted = encrypt_content(encrypted, key)
        assert double_encrypted == encrypted  # Should not re-encrypt
        
        # Test with non-encrypted content for decrypt
        non_encrypted = b"Not encrypted"
        result = decrypt_content(non_encrypted, key)
        assert result == non_encrypted  # Should return as-is
```

5. Create `tests/test_hooks.py`:
```python
import tempfile
from pathlib import Path
import os
import stat
import subprocess

from eval_crypt.hooks import install_hooks, check_hooks_installed


def test_install_hooks():
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a fake .git/hooks directory
        hooks_dir = Path(tmpdir) / ".git" / "hooks"
        hooks_dir.mkdir(parents=True)
        
        # Install hooks
        result = install_hooks(tmpdir)
        assert result is True
        
        # Check that hooks were created
        pre_commit_path = hooks_dir / "pre-commit"
        post_merge_path = hooks_dir / "post-merge"
        assert pre_commit_path.exists()
        assert post_merge_path.exists()
        
        # Check that hooks are executable
        assert os.access(pre_commit_path, os.X_OK)
        assert os.access(post_merge_path, os.X_OK)
        
        # Check hook content
        with open(pre_commit_path, "r") as f:
            pre_commit_content = f.read()
            assert "eval-crypt encrypt" in pre_commit_content
        
        with open(post_merge_path, "r") as f:
            post_merge_content = f.read()
            assert "eval-crypt decrypt" in post_merge_content


def test_check_hooks_installed():
    with tempfile.TemporaryDirectory() as tmpdir:
        # Create a fake .git/hooks directory
        hooks_dir = Path(tmpdir) / ".git" / "hooks"
        hooks_dir.mkdir(parents=True)
        
        # Check before installation
        assert not check_hooks_installed(tmpdir)
        
        # Install hooks
        install_hooks(tmpdir)
        
        # Check after installation
        assert check_hooks_installed(tmpdir)
        
        # Modify a hook to not contain eval-crypt
        with open(hooks_dir / "pre-commit", "w") as f:
            f.write("#!/bin/sh\nexit 0\n")
        
        # Check should now fail
        assert not check_hooks_installed(tmpdir)
```

6. Create `tests/test_git_config.py`:
```python
import tempfile
from pathlib import Path
import subprocess

from eval_crypt.git_config import configure_git_filters, check_git_filters_configured


def test_git_filter_configuration():
    with tempfile.TemporaryDirectory() as tmpdir:
        # Initialize a Git repository
        repo_path = Path(tmpdir)
        subprocess.run(["git", "init"], cwd=repo_path, check=True)
        
        # Check before configuration
        assert not check_git_filters_configured(repo_path)
        
        # Configure filters
        result = configure_git_filters(repo_path)
        assert result is True
        
        # Check after configuration
        assert check_git_filters_configured(repo_path)
        
        # Verify filter settings
        clean_result = subprocess.run(
            ["git", "config", "--get", "filter.eval-crypt.clean"],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        assert "eval-crypt clean" in clean_result.stdout
        
        smudge_result = subprocess.run(
            ["git", "config", "--get", "filter.eval-crypt.smudge"],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        assert "eval-crypt smudge" in smudge_result.stdout
        
        required_result = subprocess.run(
            ["git", "config", "--get", "filter.eval-crypt.required"],
            cwd=repo_path,
            capture_output=True,
            text=True,
        )
        assert "true" in required_result.stdout
```

7. Create `tests/conftest.py` for shared test fixtures:
```python
import pytest
import tempfile
import os
import subprocess
from pathlib import Path


@pytest.fixture
def git_repo():
    """Create a temporary Git repository for testing."""
    with tempfile.TemporaryDirectory() as tmpdir:
        # Initialize Git repository
        subprocess.run(["git", "init"], cwd=tmpdir, check=True)
        
        # Configure Git user for commits
        subprocess.run(["git", "config", "user.name", "Test User"], cwd=tmpdir, check=True)
        subprocess.run(["git", "config", "user.email", "test@example.com"], cwd=tmpdir, check=True)
        
        yield Path(tmpdir)
```

# Test Strategy:
Run the test suite with pytest to verify all functionality. Ensure tests cover all core functionality, edge cases, and error handling. Use code coverage tools to identify any untested code paths. Test on different operating systems (Windows, macOS, Linux) to ensure cross-platform compatibility.

# Subtasks:
## 1. Integrate key management into eval-crypt init [in-progress]
### Dependencies: None
### Description: Update the eval-crypt CLI 'init' command to generate and store a secret key if one does not exist. Ensure the key is created and saved securely during initialization, and is used by all encryption/decryption operations.
### Details:
- Modify the CLI 'init' command to call the key generation logic from crypto.py
- Store the key in a secure file (e.g., eval-crypt.key) in the project root
- Ensure the key is not overwritten if it already exists
- Add or update tests to verify key creation during init
- Document the key management behavior in the README if needed

## 2. Add pre-commit hooks for ruff and mypy [pending]
### Dependencies: None
### Description: Set up pre-commit hooks to run ruff (linter) and mypy (type checker) on staged files. Add ruff and mypy to the test dependencies in pyproject.toml. Reinstall test dependencies and ensure both tools pass before opening a PR.
### Details:
- Add ruff and mypy to [project.optional-dependencies] test group in pyproject.toml
- Add pre-commit hooks for ruff and mypy in .pre-commit-config.yaml
- Reinstall test dependencies (pip install -e .[test])
- Run ruff and mypy to ensure code passes linting and type checks
- Only open a PR if both tools pass successfully


# Task ID: 6
# Title: Implement CLI Commands
# Status: done
# Dependencies: 2, 3, 4, 5
# Priority: high
# Description: Create a command-line interface using Click to provide easy access to eval-crypt functionality.
# Details:
Create a module `eval_crypt/cli.py` to implement the CLI using Click:

```python
import click
import os
from pathlib import Path

from eval_crypt.crypto import create_or_read_secret_key, encrypt_file, decrypt_file
from eval_crypt.gitattributes import add_sensitive_file, remove_sensitive_file, get_sensitive_files
from eval_crypt.git_config import configure_git_filters, check_git_filters_configured
from eval_crypt.hooks import install_hooks, check_hooks_installed


@click.group()
def cli():
    """eval-crypt: Encrypt sensitive AI safety evaluation files in Git repositories."""
    pass


@cli.command()
def init():
    """Initialize eval-crypt in the current repository."""
    # Create secret key
    key_path = Path("anti-pretraining.sk")
    if key_path.exists():
        click.echo(f"Secret key already exists at {key_path}")
    else:
        sk = create_or_read_secret_key(key_path)
        click.echo(f"Created new secret key at {key_path}")
    
    # Configure Git filters
    if check_git_filters_configured():
        click.echo("Git filters already configured")
    else:
        if configure_git_filters():
            click.echo("Configured Git filters for eval-crypt")
        else:
            click.echo("Failed to configure Git filters")
    
    # Install Git hooks
    if check_hooks_installed():
        click.echo("Git hooks already installed")
    else:
        if install_hooks():
            click.echo("Installed Git hooks for eval-crypt")
        else:
            click.echo("Failed to install Git hooks")
    
    click.echo("eval-crypt initialized successfully")


@cli.command()
@click.argument("file_pattern")
def add(file_pattern):
    """Add a file pattern to the list of sensitive files."""
    add_sensitive_file(file_pattern)
    click.echo(f"Added {file_pattern} to sensitive files")


@cli.command()
@click.argument("file_pattern")
def remove(file_pattern):
    """Remove a file pattern from the list of sensitive files."""
    if remove_sensitive_file(file_pattern):
        click.echo(f"Removed {file_pattern} from sensitive files")
    else:
        click.echo(f"File pattern {file_pattern} not found in sensitive files")


@cli.command()
def list():
    """List all sensitive file patterns."""
    sensitive_files = get_sensitive_files()
    if sensitive_files:
        click.echo("Sensitive files:")
        for file_pattern in sensitive_files:
            click.echo(f"  {file_pattern}")
    else:
        click.echo("No sensitive files configured")


@cli.command()
def encrypt():
    """Encrypt all sensitive files (used by pre-commit hook)."""
    sk = create_or_read_secret_key()
    sensitive_patterns = get_sensitive_files()
    
    # Find files matching the patterns
    files_to_encrypt = []
    for pattern in sensitive_patterns:
        # Handle simple file patterns (not directories or wildcards)
        if os.path.exists(pattern) and os.path.isfile(pattern):
            files_to_encrypt.append(pattern)
        # TODO: Handle more complex patterns with glob
    
    if not files_to_encrypt:
        click.echo("No sensitive files found to encrypt")
        return
    
    for file_path in files_to_encrypt:
        try:
            # Skip already encrypted files
            if file_path.endswith(".enc"):
                continue
                
            # Skip if the encrypted version exists (file already encrypted)
            if os.path.exists(f"{file_path}.enc"):
                continue
                
            encrypt_file(file_path, sk)
            click.echo(f"Encrypted {file_path}")
        except Exception as e:
            click.echo(f"Failed to encrypt {file_path}: {e}")


@cli.command()
def decrypt():
    """Decrypt all sensitive files (used by post-merge hook)."""
    sk = create_or_read_secret_key()
    sensitive_patterns = get_sensitive_files()
    
    # Find encrypted files
    files_to_decrypt = []
    for pattern in sensitive_patterns:
        enc_pattern = f"{pattern}.enc"
        if os.path.exists(enc_pattern) and os.path.isfile(enc_pattern):
            files_to_decrypt.append(pattern)
        # TODO: Handle more complex patterns with glob
    
    if not files_to_decrypt:
        click.echo("No encrypted files found to decrypt")
        return
    
    for file_path in files_to_decrypt:
        try:
            decrypt_file(file_path, sk)
            click.echo(f"Decrypted {file_path}")
        except Exception as e:
            click.echo(f"Failed to decrypt {file_path}: {e}")


@cli.command()
@click.argument("file_path")
def clean(file_path):
    """Git clean filter to encrypt a file (used by Git)."""
    # This is called by Git during staging
    sk = create_or_read_secret_key()
    try:
        with open(file_path, "rb") as f:
            content = f.read()
        
        # Encrypt the content
        cipher = AES.new(sk, AES.MODE_CTR)
        encrypted = cipher.encrypt(content)
        nonce = b64encode(cipher.nonce).decode("utf-8")
        ct = b64encode(encrypted).decode("utf-8")
        result = json.dumps({"nonce": nonce, "ciphertext": ct})
        
        # Output to stdout for Git to capture
        click.echo(result, nl=False)
    except Exception as e:
        # On error, return the original content
        with open(file_path, "rb") as f:
            click.echo(f.read(), nl=False)


@cli.command()
@click.argument("file_path")
def smudge(file_path):
    """Git smudge filter to decrypt a file (used by Git)."""
    # This is called by Git during checkout
    sk = create_or_read_secret_key()
    try:
        # Read from stdin (Git provides the content)
        content = click.get_text_stream("stdin").read()
        
        # Try to decrypt
        try:
            data = json.loads(content)
            nonce = b64decode(data["nonce"])
            ciphertext = b64decode(data["ciphertext"])
            cipher = AES.new(sk, AES.MODE_CTR, nonce=nonce)
            decrypted = cipher.decrypt(ciphertext)
            click.echo(decrypted, nl=False)
        except (json.JSONDecodeError, KeyError, ValueError):
            # If not valid JSON or not our format, return as is
            click.echo(content, nl=False)
    except Exception as e:
        # On error, return the input unchanged
        click.echo(content, nl=False)


def main():
    cli()


if __name__ == "__main__":
    main()
```

# Test Strategy:
Create unit tests for each CLI command. Use the Click testing utilities to simulate command invocations. Test the init, add, remove, list, encrypt, and decrypt commands with various inputs. Verify that the commands correctly interact with the underlying modules. Test error handling and edge cases, such as adding a file that's already in the list or removing a file that's not in the list.

# Subtasks:
## 1. Complete CLI Implementation with Missing Imports [done]
### Dependencies: None
### Description: Finalize the CLI implementation by adding missing imports and completing the clean/smudge functions that are referenced but not fully implemented.
### Details:
1. Add the missing imports at the top of the file:
```python
import json
from base64 import b64encode, b64decode
from Crypto.Cipher import AES
```

2. Ensure the clean and smudge functions are properly implemented with the correct AES encryption/decryption logic.

3. Verify that all CLI commands are properly connected to their corresponding functionality in the other modules.

4. Add proper error handling for all commands, especially for file operations that might fail.

5. Implement the TODO items for handling complex file patterns with glob in the encrypt and decrypt commands.

## 2. Implement CLI Unit Tests [done]
### Dependencies: None
### Description: Create comprehensive unit tests for the CLI commands to ensure they function correctly and handle edge cases appropriately.
### Details:
Create a new file `tests/test_cli.py` with the following structure:

```python
import os
import tempfile
import pytest
from click.testing import CliRunner
from pathlib import Path

from eval_crypt.cli import cli, init, add, remove, list, encrypt, decrypt, clean, smudge

@pytest.fixture
def runner():
    return CliRunner()

@pytest.fixture
def temp_git_repo():
    with tempfile.TemporaryDirectory() as tmpdir:
        # Set up a mock git repo
        os.chdir(tmpdir)
        os.system('git init')
        yield Path(tmpdir)

def test_init_command(runner, temp_git_repo):
    result = runner.invoke(init)
    assert result.exit_code == 0
    assert "eval-crypt initialized successfully" in result.output
    assert Path("anti-pretraining.sk").exists()

def test_add_remove_list_commands(runner, temp_git_repo):
    # Test add command
    result = runner.invoke(add, ["test.txt"])
    assert result.exit_code == 0
    assert "Added test.txt to sensitive files" in result.output
    
    # Test list command
    result = runner.invoke(list)
    assert result.exit_code == 0
    assert "test.txt" in result.output
    
    # Test remove command
    result = runner.invoke(remove, ["test.txt"])
    assert result.exit_code == 0
    assert "Removed test.txt from sensitive files" in result.output
    
    # Verify it's gone
    result = runner.invoke(list)
    assert result.exit_code == 0
    assert "No sensitive files configured" in result.output

def test_encrypt_decrypt_commands(runner, temp_git_repo):
    # Create a test file
    test_content = "This is sensitive data"
    with open("test.txt", "w") as f:
        f.write(test_content)
    
    # Add it as sensitive
    runner.invoke(add, ["test.txt"])
    
    # Test encrypt
    result = runner.invoke(encrypt)
    assert result.exit_code == 0
    assert "Encrypted test.txt" in result.output
    assert Path("test.txt.enc").exists()
    
    # Test decrypt
    os.remove("test.txt")  # Remove original to test decryption
    result = runner.invoke(decrypt)
    assert result.exit_code == 0
    assert "Decrypted test.txt" in result.output
    assert Path("test.txt").exists()
    
    # Verify content
    with open("test.txt", "r") as f:
        assert f.read() == test_content

def test_clean_smudge_commands(runner, temp_git_repo):
    # Create a test file
    test_content = "This is sensitive data"
    with open("test.txt", "w") as f:
        f.write(test_content)
    
    # Test clean filter
    result = runner.invoke(clean, ["test.txt"])
    assert result.exit_code == 0
    # Output should be JSON with nonce and ciphertext
    assert "nonce" in result.output
    assert "ciphertext" in result.output
    
    # Test smudge filter by piping clean output to smudge
    with tempfile.NamedTemporaryFile(mode='w+') as tmp:
        tmp.write(result.output)
        tmp.flush()
        tmp.seek(0)
        # Simulate stdin with the encrypted content
        smudge_result = runner.invoke(smudge, ["test.txt"], input=result.output)
        assert smudge_result.exit_code == 0
        assert smudge_result.output == test_content
```

## 3. Implement file management logic for CLI commands [done]
### Dependencies: None
### Description: Replace the stub logic in the CLI commands (add, remove, list) with real logic to manage the list of files to be encrypted/decrypted. Store the managed file list in a config file (e.g., .eval-crypt-files or similar) and ensure all commands update and read from this file appropriately.
### Details:
- Implement persistent storage for the managed file list (e.g., in a .eval-crypt-files config file)
- Update the add command to append new files to the list
- Update the remove command to delete files from the list
- Update the list command to display all managed files
- Ensure proper error handling and idempotency for all commands
- Update or add tests to cover the new logic
<info added on 2025-07-10T12:43:50.680Z>
Implement persistent storage for managed file list in .gitattributes using 'filter=eval-crypt' attribute, similar to the transcrypt project
- Update the add command to append new file patterns to .gitattributes with the 'filter=eval-crypt' attribute
- Update the remove command to delete file patterns from .gitattributes
- Update the list command to display all managed files by parsing .gitattributes
- Ensure .gitattributes is the canonical source of truth for which files are managed for encryption/decryption
- Implement proper error handling for cases where .gitattributes doesn't exist or has invalid format
- Update or add tests to cover the new .gitattributes-based storage logic
</info added on 2025-07-10T12:43:50.680Z>

